<!DOCTYPE html>
<html>
<head>
    <title>Suffixia: Word Warden Master Edition</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <style>
        body { 
            margin: 0; background: #222; overflow: hidden; 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            color: white; user-select: none; -webkit-user-select: none;
            touch-action: none; /* HARD STOP on browser zooming gestures */
        }
        canvas { display: block; background: #111; margin: 0 auto; image-rendering: pixelated; }
        
        #hud {
            position: absolute; top: 15px; left: 15px;
            background: rgba(20, 20, 30, 0.85); padding: 12px 20px; border-radius: 16px;
            border: 2px solid rgba(255,255,255,0.2); pointer-events: none;
            display: flex; gap: 20px; font-size: 18px; font-weight: bold; z-index: 10;
        }
        .hud-item { display: flex; align-items: center; gap: 8px; text-shadow: 1px 1px 0 #000; }
        .hud-value { color: #55efc4; }

        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(10, 10, 15, 0.98); z-index: 200;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        #start-btn {
            padding: 20px 60px; font-size: 24px; font-weight: bold; 
            background: linear-gradient(45deg, #6c5ce7, #a29bfe); color: white; 
            border: none; border-radius: 50px; cursor: pointer; transition: transform 0.2s;
        }
        #start-btn:hover { transform: scale(1.05); }

        #ui-layer {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(15, 15, 20, 0.98); padding: 40px; border: 4px solid #6c5ce7;
            border-radius: 20px; text-align: center; display: none; 
            width: 85%; max-width: 500px; z-index: 100; box-shadow: 0 0 100px rgba(108, 92, 231, 0.6);
        }

        input { padding: 15px; font-size: 24px; text-align: center; width: 80%; margin-top: 15px; background: #2d3436; border: 3px solid #636e72; color: white; border-radius: 12px; outline: none; }
        .action-btn { padding: 15px 40px; font-size: 20px; cursor: pointer; margin-top: 30px; background: #6c5ce7; color: white; border: none; border-radius: 12px; font-weight: bold; width: 100%; }

        #mobile-controls {
            position: absolute; bottom: 30px; right: 30px;
            display: grid; grid-template-columns: 80px 80px 80px; grid-template-rows: 80px 80px; gap: 10px; z-index: 50;
        }
        .dpad-btn {
            width: 80px; height: 80px; background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.4); border-radius: 50%;
            color: white; font-size: 30px; display: flex; justify-content: center; align-items: center;
            touch-action: none; -webkit-tap-highlight-color: transparent;
        }
        /* 1. Prevent zooming on the entire interactive area */
#mobile-controls, .dpad-btn, #start-btn, .action-btn {
    touch-action: manipulation;
    -webkit-user-select: none;
    -webkit-tap-highlight-color: transparent;
}

/* 2. Force the canvas to ignore double-tap gestures */
canvas {
    touch-action: none;
}
    </style>
</head>
<body>

    <div id="start-screen">
        <h1 style="font-size: 60px; color: #a29bfe; margin-bottom: 20px;">SUFFIXIA</h1>
        <p style="color:#ccc; margin-bottom: 50px; font-size: 20px;">The Legend of the Word Warden</p>
        <button id="start-btn" onclick="initGame()">START ADVENTURE</button>
    </div>
    
    <div id="hud">
        <div class="hud-item">üèÜ <span id="score-val" class="hud-value">0</span></div>
        <div class="hud-item">üîë <span id="key-count" class="hud-value">0</span></div>
        <div class="hud-item">üß™ <span id="potion-status" class="hud-value">OFF</span></div>
        <div id="rank-display" style="color:#ffeaa7; margin-left: 10px;">NOVICE</div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <div id="mobile-controls">
        <div class="dpad-btn" style="grid-column: 2; grid-row: 1;" onpointerdown="handleInput(event, 0, -1)">‚ñ≤</div>
        <div class="dpad-btn" style="grid-column: 1; grid-row: 2;" onpointerdown="handleInput(event, -1, 0)">‚óÄ</div>
        <div class="dpad-btn" style="grid-column: 2; grid-row: 2;" onpointerdown="handleInput(event, 0, 1)">‚ñº</div>
        <div class="dpad-btn" style="grid-column: 3; grid-row: 2;" onpointerdown="handleInput(event, 1, 0)">‚ñ∂</div>
    </div>

    <div id="ui-layer">
        <h2 id="ui-title">Quest</h2>
        <p id="ui-text">...</p>
        <div id="battle-ui" style="display:none">
            <input type="text" id="answer" placeholder="Type answer..." autocomplete="off">
            <button class="action-btn" onclick="checkAnswer()">CAST SPELL</button>
        </div>
        <button id="close-btn" class="action-btn" onclick="closeUI()" style="display:none">CONTINUE</button>
        <p id="feedback" style="color:#ff7675; font-weight:bold; margin-top:15px;"></p>
    </div>

    <script>
        const TILE_SIZE = 80;
        const CANVAS = document.getElementById("gameCanvas");
        const CTX = CANVAS.getContext("2d");

        // --- FULLY RESTORED ORIGINAL CONTENT ---
        const REGULAR_QUESTIONS = [
            { a: "greenish", q: "Somewhat green." }, { a: "boyish", q: "Like a boy." },
            { a: "girlish", q: "Like a girl." }, { a: "childish", q: "Immature; like a child." },
            { a: "ticklish", q: "Sensitive to tickling." }, { a: "feverish", q: "Having a fever." },
            { a: "stylish", q: "Fashionable." }, { a: "foolish", q: "Lacking sense." },
            { a: "selfish", q: "Caring only for self." }, { a: "pinkish", q: "Slightly pink." }
        ];
        const BOSS_QUESTIONS = [
            { a: "adjective", q: "Does the suffix '-ish' turn a noun into a Verb or Adjective?" },
            { a: "quality of", q: "Does '-ish' mean 'without' or 'having the quality of'?" },
            { a: "noun", q: "To make 'Foolish', do you add -ish to a Noun or Verb?" }
        ];
        const STORY_TEXT = [
            "Welcome, Word Warden. The Suffix Sorcerer has stolen the endings of our words! You must reclaim them!",
            "You have entered the Chasm. The rooms are split by a great wall. You must find the key to open the central door!",
            "The Throne Room. The Sorcerer waits behind the final door."
        ];
        const RANKS = [
            { score: 0, title: "NOVICE" }, { score: 200, title: "APPRENTICE" }, { score: 500, title: "SPELLBINDER" }, { score: 800, title: "WORD MASTER" }, { score: 1200, title: "LEGEND" }
        ];

        // --- RESTORED SYSTEMS ---
        let particles = [];
        function createParticles(x, y, color, count=10) {
            for(let i=0; i<count; i++) {
                particles.push({
                    x: x * TILE_SIZE + TILE_SIZE/2, y: y * TILE_SIZE + TILE_SIZE/2,
                    vx: (Math.random() - 0.5) * 12, vy: (Math.random() - 0.5) * 12,
                    life: 1.0, color: color
                });
            }
        }

        const Audio = {
            ctx: null, active: false,
            init: function() {
                try {
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    this.ctx = new AudioContext(); this.active = true;
                    this.startBGM();
                } catch (e) { this.active = false; }
            },
            playTone: function(freq, type, duration, vol=0.1) {
                if (!this.active || !this.ctx) return;
                const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain();
                osc.type = type; osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
                osc.connect(gain); gain.connect(this.ctx.destination);
                osc.start(); osc.stop(this.ctx.currentTime + duration);
            },
            pickup: () => Audio.playTone(800, 'sine', 0.2),
            unlock: () => Audio.playTone(300, 'square', 0.3),
            magic: () => Audio.playTone(600, 'sine', 0.4),
            error: () => Audio.playTone(100, 'sawtooth', 0.3),
            step: () => Audio.playTone(50, 'triangle', 0.05, 0.02),
            levelup: () => { [440, 554, 659, 880].forEach((n, i) => setTimeout(() => Audio.playTone(n, 'square', 0.4), i * 100)); },
            startBGM: function() {
                if (!this.active) return;
                const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain();
                osc.frequency.value = 50; osc.type = 'triangle'; gain.gain.value = 0.05; 
                osc.connect(gain); gain.connect(this.ctx.destination); osc.start();
            }
        };

        const ASSETS = { "@": "images/hero.png", "#": "images/wall.png", "N": "images/npc.png", ">": "images/stairs.png", "E": "images/enemy.png", "$": "images/boss.png" };
        const IMAGES = {};
        for (let key in ASSETS) { const img = new Image(); img.src = ASSETS[key]; IMAGES[key] = img; }

        let player = { x: 1, y: 1 };
        let inventory = { keys: 0, score: 0, vision: false };
        let levelIdx = 0;
        let isPaused = false;
        let currentEnemy = null;
        let walls = [];
        let items = [];
        let moveTimer = 0;
        let shake = 0;

        const LEVELS = [
            [ "####################", "#@.......E....K....#", "#.N...H............#", "#######D############", "#...........E......#", "#...P.......#......#", "#...#.......E......#", "#...#...E....>.....#", "#...#..............#", "####################" ],
            [ "#######################", "#@........#...........#", "#.........#...........#", "#...E.....#.....E.....#", "#.........D...........#", "#...K.....#...........#", "#.........#......>....#", "#.........#...........#", "#######################" ],
            [ "#######################", "#@.................K..#", "#..#################..#", "#..#...............#..#", "#..#...E...$.......#..#", "#..#...............#..#", "#..#######...#######..#", "#..........D..........#", "#######################" ]
        ];

        function initGame() {
            document.getElementById("start-screen").style.display = "none";
            Audio.init();
            loadLevel(0);
            resize();
            requestAnimationFrame(gameLoop);
        }

        function loadLevel(idx) {
            levelIdx = idx;
            if (levelIdx >= LEVELS.length) { Audio.levelup(); alert("VICTORY!"); location.reload(); return; }
            if (idx > 0) Audio.levelup();
            const map = LEVELS[levelIdx];
            walls = []; items = [];
            for (let y = 0; y < map.length; y++) {
                for (let x = 0; x < map[y].length; x++) {
                    let c = map[y][x];
                    if (c === "#") walls.push({x, y});
                    else if (c === "@") { player.x = x; player.y = y; }
                    else if ("EKD>$NHP".includes(c)) {
                        let pool = (c === "$") ? BOSS_QUESTIONS : REGULAR_QUESTIONS;
                        items.push({ x, y, type: c, quest: pool[Math.floor(Math.random()*pool.length)], isMoving: (c === "E") });
                    }
                }
            }
            updateHUD();
            openUI("CHAPTER " + (idx+1), STORY_TEXT[idx], false);
        }

        function updateHUD() {
            document.getElementById("key-count").innerText = inventory.keys;
            document.getElementById("score-val").innerText = inventory.score;
            document.getElementById("potion-status").innerText = inventory.vision ? "ON" : "OFF";
            let rank = "NOVICE";
            RANKS.forEach(r => { if(inventory.score >= r.score) rank = r.title; });
            document.getElementById("rank-display").innerText = rank;
        }

        function gameLoop() {
            if(!isPaused) {
                // Enemy Movement
                moveTimer++;
                if (moveTimer > 60) {
                    moveTimer = 0;
                    items.forEach(i => {
                        if (i.isMoving) {
                            let d = [[0,1],[0,-1],[1,0],[-1,0]][Math.floor(Math.random()*4)];
                            let nx = i.x + d[0], ny = i.y + d[1];
                            if (!walls.some(w=>w.x===nx&&w.y===ny) && player.x!==nx && player.y!==ny) { i.x = nx; i.y = ny; }
                        }
                    });
                }
                particles.forEach(p => { p.x += p.vx; p.y += p.vy; p.life -= 0.05; });
                particles = particles.filter(p => p.life > 0);
                if(shake > 0) shake--;
                draw();
            }
            requestAnimationFrame(gameLoop);
        }

        function draw() {
            CTX.fillStyle = "#111"; CTX.fillRect(0, 0, CANVAS.width, CANVAS.height);
            const map = LEVELS[levelIdx];
            const mapW = map[0].length, mapH = map.length;
            const padding = 60;
            const scale = Math.min((CANVAS.width-padding)/(mapW*TILE_SIZE), (CANVAS.height-padding)/(mapH*TILE_SIZE), 1.0);
            
            let sX = shake > 0 ? (Math.random()-0.5)*10 : 0;
            let sY = shake > 0 ? (Math.random()-0.5)*10 : 0;

            CTX.save();
            CTX.translate(CANVAS.width/2 + sX, CANVAS.height/2 + sY);
            CTX.scale(scale, scale);
            CTX.translate(-(mapW*TILE_SIZE)/2, -(mapH*TILE_SIZE)/2);

            for(let y=0; y<mapH; y++) {
                for(let x=0; x<mapW; x++) {
                    CTX.fillStyle = (x+y)%2 === 0 ? "#222" : "#2a2a2a";
                    CTX.fillRect(x*TILE_SIZE, y*TILE_SIZE, TILE_SIZE, TILE_SIZE);
                }
            }
            walls.forEach(w => drawTile(w.x, w.y, "#", 0));
            const bob = Math.sin(Date.now()/200)*5;
            items.forEach(i => {
                if (i.type === "H" && !inventory.vision) return; 
                drawTile(i.x, i.y, i.type, (i.isMoving || i.type === "N" || i.type === "$") ? bob : 0);
            });
            drawTile(player.x, player.y, "@", bob);
            
            particles.forEach(p => {
                CTX.globalAlpha = p.life; CTX.fillStyle = p.color;
                CTX.fillRect(p.x, p.y, 6, 6);
            });
            CTX.globalAlpha = 1.0;
            CTX.restore();
        }

        function drawTile(x, y, type, yOff) {
            const img = IMAGES[type];
            if (img && img.complete && img.naturalHeight !== 0) {
                CTX.drawImage(img, x*TILE_SIZE, y*TILE_SIZE + yOff, TILE_SIZE, TILE_SIZE);
            } else {
                CTX.textAlign = "center"; CTX.textBaseline = "middle"; CTX.font = "40px Arial";
                let syms = {"#":"‚¨õ","K":"üîë","D":"üîí","E":"üëæ","$":"üëπ","@":"üßô",">":"üö™","P":"üß™","H":"‚ö†Ô∏è","N":"üë§"};
                CTX.fillText(syms[type] || "?", x*TILE_SIZE + 40, y*TILE_SIZE + 40 + yOff);
            }
        }

        function handleInput(e, dx, dy) {
            if (e && e.cancelable) e.preventDefault(); 
            if (isPaused) return;
            let nx = player.x + dx, ny = player.y + dy;
            if (walls.some(w => w.x === nx && w.y === ny)) { Audio.error(); shake = 5; return; }

            let item = items.find(i => i.x === nx && i.y === ny);
            if (item) {
                if (item.type === "K") { inventory.keys++; Audio.pickup(); createParticles(nx, ny, "#ffeaa7"); items = items.filter(i=>i!==item); player.x = nx; player.y = ny; }
                else if (item.type === "P") { inventory.vision = true; Audio.pickup(); createParticles(nx, ny, "#55efc4"); items = items.filter(i=>i!==item); openUI("POTION", "Hidden traps revealed!", false); player.x = nx; player.y = ny; }
                else if (item.type === "D") { 
                    if(inventory.keys > 0) { 
                        inventory.keys--; Audio.unlock(); createParticles(nx, ny, "#e67e22"); items = items.filter(i=>i!==item); player.x = nx; player.y = ny; 
                    } else { openUI("LOCKED", "Find a key üîë first!", false); }
                }
                else if ("EH$".includes(item.type)) { currentEnemy = item; openUI(item.type==="$"?"BOSS BATTLE":"BATTLE", item.quest.q, true); }
                else if (item.type === ">") { inventory.score += 100; loadLevel(levelIdx+1); }
                else if (item.type === "N") { openUI("WIZARD", "Collect the suffixes to save the kingdom!", false); }
            } else { player.x = nx; player.y = ny; Audio.step(); }
            updateHUD();
        }

        function openUI(title, text, isBattle) {
            isPaused = true; document.getElementById("ui-layer").style.display = "block";
            document.getElementById("ui-title").innerText = title;
            document.getElementById("ui-text").innerText = text;
            document.getElementById("battle-ui").style.display = isBattle ? "block" : "none";
            document.getElementById("close-btn").style.display = isBattle ? "none" : "block";
            document.getElementById("feedback").innerText = "";
            if(isBattle) setTimeout(()=>document.getElementById("answer").focus(), 100);
        }
        function closeUI() { document.getElementById("ui-layer").style.display = "none"; isPaused = false; }
        
        window.checkAnswer = function() {
            let ans = document.getElementById("answer").value.toLowerCase().trim();
            if (ans === currentEnemy.quest.a) {
                Audio.magic(); createParticles(currentEnemy.x, currentEnemy.y, "#a29bfe", 20);
                items = items.filter(i=>i!==currentEnemy); 
                inventory.score += (currentEnemy.type === "$" ? 500 : 50); 
                closeUI();
                document.getElementById("answer").value = "";
                if (currentEnemy.type === "$") { Audio.levelup(); setTimeout(()=>alert("BOSS DEFEATED!"), 500); }
            } else { Audio.error(); shake = 5; document.getElementById("feedback").innerText = "WRONG!"; }
            updateHUD();
        }

        function resize() { CANVAS.width = window.innerWidth; CANVAS.height = window.innerHeight; }
        window.addEventListener('resize', resize);
        window.addEventListener('keydown', e => {
            if(e.key === "ArrowUp") handleInput(null,0,-1);
            if(e.key === "ArrowDown") handleInput(null,0,1);
            if(e.key === "ArrowLeft") handleInput(null,-1,0);
            if(e.key === "ArrowRight") handleInput(null,1,0);
            if(e.key === "Enter" && document.getElementById("ui-layer").style.display === "block") checkAnswer();
        });
    </script>
</body>
</html>
