<!DOCTYPE html>
<html>
<head>
    <title>Suffixia: Crystal Clear Edition</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        body { 
            margin: 0; 
            background: #222; /* Lighter background for better contrast outside map */
            overflow: hidden; 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            color: white; 
            user-select: none;
            -webkit-user-select: none;
            touch-action: none; 
        }
        
        canvas { 
            display: block; 
            background: #111; 
            margin: 0 auto;
            image-rendering: pixelated; /* CRISP PIXELS */
        }
        
        /* HUD */
        #hud {
            position: absolute; top: 15px; left: 15px;
            background: rgba(20, 20, 30, 0.85); 
            padding: 12px 20px; border-radius: 16px;
            border: 2px solid rgba(255,255,255,0.2); 
            pointer-events: none;
            display: flex; gap: 20px; font-size: 18px; font-weight: bold;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5); z-index: 10;
        }
        .hud-item { display: flex; align-items: center; gap: 8px; text-shadow: 1px 1px 0 #000; }
        .hud-value { color: #55efc4; }

        /* START SCREEN */
        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(10, 10, 15, 0.98); z-index: 200;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        #start-btn {
            padding: 20px 60px; font-size: 24px; font-weight: bold; 
            background: linear-gradient(45deg, #6c5ce7, #a29bfe); 
            color: white; border: none; border-radius: 50px;
            cursor: pointer; box-shadow: 0 0 30px rgba(108, 92, 231, 0.5);
            transition: transform 0.2s;
        }
        #start-btn:hover { transform: scale(1.05); }

        /* UI POPUP */
        #ui-layer {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(15, 15, 20, 0.98); 
            color: #eee; 
            padding: 40px; 
            border: 4px solid #6c5ce7;
            border-radius: 20px;
            text-align: center; 
            display: none; 
            width: 85%; max-width: 500px;
            box-shadow: 0 0 100px rgba(108, 92, 231, 0.6);
            z-index: 100;
        }

        h2#ui-title { margin-top: 0; color: #a29bfe; text-transform: uppercase; letter-spacing: 4px; border-bottom: 2px solid #444; padding-bottom: 20px; font-size: 24px;}
        p#ui-text { font-size: 20px; line-height: 1.6; margin: 30px 0; color: #fff; }

        input { 
            padding: 15px; font-size: 24px; text-align: center; width: 80%; margin-top: 15px;
            background: #2d3436; border: 3px solid #636e72; color: white; border-radius: 12px; outline: none;
        }
        input:focus { border-color: #a29bfe; }
        
        button.action-btn { 
            padding: 15px 40px; font-size: 20px; cursor: pointer; margin-top: 30px;
            background: #6c5ce7; color: white; border: none; border-radius: 12px; font-weight: bold;
            width: 100%; transition: background 0.2s;
        }
        button.action-btn:hover { background: #81ecec; color: #2d3436; }

        /* CONTROLS */
        #mobile-controls {
            position: absolute; bottom: 30px; left: 30px;
            display: grid; 
            grid-template-columns: 80px 80px 80px;
            grid-template-rows: 80px 80px;
            gap: 10px; z-index: 50;
        }
        .dpad-btn {
            width: 80px; height: 80px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 50%;
            color: white; font-size: 30px;
            display: flex; justify-content: center; align-items: center;
            cursor: pointer;
        }
        .dpad-btn:active { background: rgba(108, 92, 231, 0.8); }
        #btn-up { grid-column: 2; grid-row: 1; }
        #btn-left { grid-column: 1; grid-row: 2; }
        #btn-down { grid-column: 2; grid-row: 2; }
        #btn-right { grid-column: 3; grid-row: 2; }
    </style>
</head>
<body>

    <div id="start-screen">
        <h1 style="font-size: 60px; color: #a29bfe; margin-bottom: 20px;">SUFFIXIA</h1>
        <p style="color:#ccc; margin-bottom: 50px; font-size: 20px;">The Legend of the Word Warden</p>
        <button id="start-btn" onclick="initGame()">START ADVENTURE</button>
    </div>
    
    <div id="hud">
        <div class="hud-item">üèÜ <span id="score-val" class="hud-value">0</span></div>
        <div class="hud-item">üîë <span id="key-count" class="hud-value">0</span></div>
        <div class="hud-item">üß™ <span id="potion-status" class="hud-value">OFF</span></div>
        <div class="hud-item" style="border-left: 2px solid #555; padding-left: 15px;">
            <span id="rank-display" style="color:#ffeaa7">NOVICE</span>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <div id="mobile-controls">
        <div class="dpad-btn" id="btn-up" onpointerdown="handleInput(0, -1)">‚ñ≤</div>
        <div class="dpad-btn" id="btn-left" onpointerdown="handleInput(-1, 0)">‚óÄ</div>
        <div class="dpad-btn" id="btn-down" onpointerdown="handleInput(0, 1)">‚ñº</div>
        <div class="dpad-btn" id="btn-right" onpointerdown="handleInput(1, 0)">‚ñ∂</div>
    </div>

    <div id="ui-layer">
        <h2 id="ui-title">Quest</h2>
        <p id="ui-text">...</p>
        <div id="battle-ui" style="display:none">
            <input type="text" id="answer" placeholder="Type answer..." autocomplete="off">
            <br>
            <button class="action-btn" onclick="checkAnswer()">CAST SPELL</button>
        </div>
        <button id="close-btn" class="action-btn" onclick="closeUI()" style="display:none">CONTINUE</button>
        <p id="feedback" style="color:#ff7675; font-weight:bold; min-height: 20px; margin-top:15px;"></p>
    </div>

    <script>
        // --- 1. BIGGER TILES ---
        const TILE_SIZE = 80; // Large, clear tiles
        const CANVAS = document.getElementById("gameCanvas");
        const CTX = CANVAS.getContext("2d");

        // --- PARTICLE SYSTEM ---
        let particles = [];
        function createParticles(x, y, color, count=10) {
            for(let i=0; i<count; i++) {
                particles.push({
                    x: x * TILE_SIZE + TILE_SIZE/2,
                    y: y * TILE_SIZE + TILE_SIZE/2,
                    vx: (Math.random() - 0.5) * 12,
                    vy: (Math.random() - 0.5) * 12,
                    life: 1.0, color: color
                });
            }
        }
        function updateParticles() {
            particles.forEach(p => { p.x += p.vx; p.y += p.vy; p.life -= 0.05; });
            particles = particles.filter(p => p.life > 0);
        }
        function drawParticles(ctx, offsetX, offsetY) {
            particles.forEach(p => {
                ctx.globalAlpha = p.life; ctx.fillStyle = p.color;
                ctx.fillRect(p.x + offsetX, p.y + offsetY, 6, 6);
                ctx.globalAlpha = 1.0;
            });
        }

        // --- AUDIO ---
        const Audio = {
            ctx: null, active: false,
            init: function() {
                try {
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    this.ctx = new AudioContext();
                    this.active = true;
                    this.startBGM();
                } catch (e) { this.active = false; }
            },
            playTone: function(freq, type, duration, vol=0.1) {
                if (!this.active || !this.ctx) return;
                try {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    osc.type = type; osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                    gain.gain.setValueAtTime(vol, this.ctx.currentTime); 
                    gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
                    osc.connect(gain); gain.connect(this.ctx.destination);
                    osc.start(); osc.stop(this.ctx.currentTime + duration);
                } catch(e) {}
            },
            pickup: () => Audio.playTone(800, 'sine', 0.2),
            unlock: () => Audio.playTone(300, 'square', 0.3),
            magic: () => Audio.playTone(600, 'sine', 0.4),
            error: () => Audio.playTone(100, 'sawtooth', 0.3),
            step: () => Audio.playTone(50, 'triangle', 0.05, 0.02),
            levelup: () => { [440, 554, 659, 880].forEach((n, i) => setTimeout(() => Audio.playTone(n, 'square', 0.4), i * 100)); },
            startBGM: function() {
                if (!this.active || !this.ctx) return;
                try {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    osc.frequency.value = 50; osc.type = 'triangle';
                    gain.gain.value = 0.05; 
                    osc.connect(gain); gain.connect(this.ctx.destination);
                    osc.start();
                } catch(e) {}
            }
        };

        const ASSETS = { "@": "images/hero.png", "#": "images/wall.png", ".": "images/floor.png", "N": "images/npc.png", ">": "images/stairs.png", "E": "images/enemy.png", "$": "images/boss.png" };
        const IMAGES = {};
        let assetsLoaded = 0;
        const totalAssets = Object.keys(ASSETS).length;

        function preloadImages() {
            for (let key in ASSETS) {
                const img = new Image();
                img.src = ASSETS[key];
                img.onload = () => { assetsLoaded++; };
                img.onerror = () => { assetsLoaded++; }; 
                IMAGES[key] = img;
            }
        }
        
        const REGULAR_QUESTIONS = [
            { a: "greenish", q: "Somewhat green." }, { a: "boyish", q: "Like a boy." },
            { a: "girlish", q: "Like a girl." }, { a: "childish", q: "Immature; like a child." },
            { a: "ticklish", q: "Sensitive to tickling." }, { a: "feverish", q: "Having a fever." },
            { a: "stylish", q: "Fashionable." }, { a: "foolish", q: "Lacking sense." },
            { a: "selfish", q: "Caring only for self." }, { a: "pinkish", q: "Slightly pink." }
        ];
        const BOSS_QUESTIONS = [
            { a: "adjective", q: "Does the suffix '-ish' turn a noun into a Verb or Adjective?" },
            { a: "quality of", q: "Does '-ish' mean 'without' or 'having the quality of'?" },
            { a: "noun", q: "To make 'Foolish', do you add -ish to a Noun or Verb?" }
        ];
        const STORY_TEXT = [
            "Welcome, Word Warden. The Suffix Sorcerer has stolen the endings of our words! You must reclaim them!",
            "You have entered the Chasm. The rooms are split by a great wall. You must find the key to open the central door!",
            "The Throne Room. The Sorcerer waits behind the final door."
        ];
        const RANKS = [
            { score: 0, title: "NOVICE" }, { score: 200, title: "APPRENTICE" }, { score: 500, title: "SPELLBINDER" }, { score: 800, title: "WORD MASTER" }, { score: 1200, title: "LEGEND" }
        ];

        let player = { x: 1, y: 1 };
        let inventory = { keys: 0, vision: false, score: 0 };
        let levelIdx = 0;
        let isPaused = false;
        let currentEnemy = null;
        let walls = [];
        let items = [];
        let moveTimer = 0;
        let shake = 0;

        const LEVELS = [
            [ "####################", "#@.......E....K....#", "#.N...H............#", "#######D############", "#...........E......#", "#...P.......#......#", "#...#.......E......#", "#...#...E....>.....#", "#...#..............#", "####################" ],
            [ "#######################", "#@........#...........#", "#.........#...........#", "#...E.....#.....E.....#", "#.........D...........#", "#...K.....#...........#", "#.........#......>....#", "#.........#...........#", "#######################" ],
            [ "#######################", "#@.................K..#", "#..#################..#", "#..#...............#..#", "#..#...E...$.......#..#", "#..#...............#..#", "#..#######...#######..#", "#..........D..........#", "#######################" ]
        ];

        function initGame() {
            document.getElementById("start-screen").style.display = "none";
            Audio.init();
            resize();
            preloadImages();
            loadLevel(0);
            requestAnimationFrame(gameLoop);
        }

        function loadLevel(idx) {
            levelIdx = idx;
            if (levelIdx >= LEVELS.length) {
                Audio.levelup();
                alert(`YOU WIN! Final Score: ${inventory.score}`);
                location.reload(); 
                return;
            }
            if (idx > 0) Audio.levelup();

            const map = LEVELS[levelIdx];
            walls = [];
            items = [];

            for (let y = 0; y < map.length; y++) {
                for (let x = 0; x < map[y].length; x++) {
                    let char = map[y][x];
                    if (char === "#") walls.push({x, y});
                    else if (char === "@") { player.x = x; player.y = y; }
                    else if (char === "E" || char === "$" || char === "H") {
                        let pool = (char === "$") ? BOSS_QUESTIONS : REGULAR_QUESTIONS;
                        let qData = pool[Math.floor(Math.random() * pool.length)];
                        items.push({ x, y, type: char, quest: qData, id: Math.random(), isMoving: (char === "E") });
                    } 
                    else if ("KDP>NS".includes(char)) items.push({ x, y, type: char, id: Math.random() });
                }
            }
            updateHUD();
            setTimeout(() => openUI("CHAPTER " + (idx+1), STORY_TEXT[idx], false), 500);
        }

        function updateHUD() {
            document.getElementById("key-count").innerText = inventory.keys;
            document.getElementById("score-val").innerText = inventory.score;
            document.getElementById("potion-status").innerText = inventory.vision ? "ON" : "OFF";
            document.getElementById("potion-status").style.color = inventory.vision ? "#55efc4" : "#636e72";
            let currentRank = "NOVICE";
            for(let r of RANKS) if(inventory.score >= r.score) currentRank = r.title;
            document.getElementById("rank-display").innerText = currentRank;
        }

        function addScore(points) { inventory.score += points; updateHUD(); }

        function gameLoop() {
            if(!isPaused) { updateEnemies(); updateParticles(); draw(); }
            if(shake > 0) shake--;
            requestAnimationFrame(gameLoop);
        }

        function updateEnemies() {
            moveTimer++;
            if (moveTimer > 60) { 
                moveTimer = 0;
                items.forEach(item => {
                    if (item.isMoving) {
                        let dirs = [[0,1], [0,-1], [1,0], [-1,0]];
                        let move = dirs[Math.floor(Math.random() * dirs.length)];
                        let nx = item.x + move[0];
                        let ny = item.y + move[1];
                        if (!isWall(nx, ny) && !isPlayer(nx, ny) && !isItem(nx, ny)) {
                            item.x = nx;
                            item.y = ny;
                        }
                    }
                });
            }
        }

        function isWall(x, y) { return walls.some(w => w.x === x && w.y === y); }
        function isPlayer(x, y) { return player.x === x && player.y === y; }
        function isItem(x, y) { return items.some(i => i.x === x && i.y === y); }

        function draw() {
            let shakeX = shake > 0 ? (Math.random() - 0.5) * 10 : 0;
            let shakeY = shake > 0 ? (Math.random() - 0.5) * 10 : 0;

            CTX.fillStyle = "#111"; // Bright background
            CTX.fillRect(0, 0, CANVAS.width, CANVAS.height);
            let offsetX = (CANVAS.width / 2) - (player.x * TILE_SIZE) - (TILE_SIZE / 2) + shakeX;
            let offsetY = (CANVAS.height / 2) - (player.y * TILE_SIZE) - (TILE_SIZE / 2) + shakeY;
            
            CTX.save();
            CTX.translate(offsetX, offsetY);

            const map = LEVELS[levelIdx];
            for (let y = 0; y < map.length; y++) {
                for (let x = 0; x < map[y].length; x++) {
                    let char = map[y][x];
                    // Floor (Checkerboard)
                    if ((x+y)%2 === 0) CTX.fillStyle = "#222"; else CTX.fillStyle = "#2a2a2a";
                    CTX.fillRect(x*TILE_SIZE, y*TILE_SIZE, TILE_SIZE, TILE_SIZE);
                    
                    if (char === "#") drawTile(x, y, "#", 0);
                }
            }

            const bob = Math.sin(Date.now() / 200) * 5;
            items.forEach(item => {
                if (item.type === "H" && !inventory.vision) { /* Invisible */ } 
                else {
                    let yOffset = (item.type === "E" || item.type === "N" || item.type === "$") ? bob : 0;
                    drawTile(item.x, item.y, item.type, yOffset);
                }
            });

            drawTile(player.x, player.y, "@", bob);
            drawParticles(CTX, 0, 0); 

            // NO LIGHTING OVERLAY - FULL BRIGHTNESS
            CTX.restore();
        }

        function drawTile(x, y, type, yOffset) {
            const px = x * TILE_SIZE;
            const py = (y * TILE_SIZE) + yOffset;
            const img = IMAGES[type];
            if (img && img.complete && img.naturalHeight !== 0) {
                CTX.drawImage(img, px, py, TILE_SIZE, TILE_SIZE);
                return;
            } 
            if (type === "#") { 
                CTX.fillStyle = "#444"; 
                CTX.fillRect(px, py, TILE_SIZE, TILE_SIZE); 
                CTX.strokeStyle = "#666";
                CTX.lineWidth = 4;
                CTX.strokeRect(px, py, TILE_SIZE, TILE_SIZE);
                return; 
            }
            
            CTX.font = (TILE_SIZE * 0.6) + "px Arial";
            CTX.textAlign = "center"; CTX.textBaseline = "middle";
            let cx = px + TILE_SIZE/2; let cy = py + TILE_SIZE/2;

            if (type === "K") CTX.fillText("üîë", cx, cy);
            else if (type === "D") { CTX.fillStyle = "#e67e22"; CTX.fillRect(px, py, TILE_SIZE, TILE_SIZE); CTX.fillStyle="white"; CTX.fillText("üîí", cx, cy); }
            else if (type === "P") CTX.fillText("üß™", cx, cy);
            else if (type === "H") CTX.fillText("‚ö†Ô∏è", cx, cy);
            else if (type === "@") { CTX.fillStyle = "#6c5ce7"; CTX.fillRect(px, py, TILE_SIZE, TILE_SIZE); }
            else if (type === "E") { CTX.fillStyle = "#d63031"; CTX.fillRect(px, py, TILE_SIZE, TILE_SIZE); }
            else if (type === ">") { CTX.fillStyle = "#ffeaa7"; CTX.fillRect(px, py, TILE_SIZE, TILE_SIZE); }
            else { CTX.fillStyle = "green"; CTX.fillRect(px, py, TILE_SIZE, TILE_SIZE); }
        }

        function handleInput(dx, dy) {
            if (isPaused) return;
            if (dx !== 0 || dy !== 0) {
                let nx = player.x + dx;
                let ny = player.y + dy;
                if (isWall(nx, ny)) { Audio.error(); shake = 5; return; }

                let item = items.find(i => i.x === nx && i.y === ny);
                if (item) {
                    if (item.type === "N") { openUI("Wizard", "Greetings!", false); } 
                    else if (item.type === "K") {
                        inventory.keys++; Audio.pickup(); createParticles(nx, ny, "#ffeaa7");
                        items = items.filter(i => i !== item); addScore(20); player.x = nx; player.y = ny;
                    }
                    else if (item.type === "P") {
                        inventory.vision = true; updateHUD(); Audio.pickup(); createParticles(nx, ny, "#55efc4");
                        openUI("Potion Drinker", "Hidden traps revealed!", false); items = items.filter(i => i !== item); addScore(20); player.x = nx; player.y = ny;
                    }
                    else if (item.type === "D") {
                        if (inventory.keys > 0) {
                            inventory.keys--; Audio.unlock(); createParticles(nx, ny, "#e67e22");
                            items = items.filter(i => i !== item); openUI("Unlocked!", "Door opened.", false); updateHUD();
                        } else {
                            openUI("Locked", "You need a key üîë.", false);
                        }
                    }
                    else if (item.type === "E" || item.type === "H") {
                        currentEnemy = item; openUI("BATTLE", item.quest.q, true);
                    }
                    else if (item.type === "$") {
                        currentEnemy = item; openUI("BOSS BATTLE", item.quest.q, true);
                    } 
                    else if (item.type === ">") {
                        addScore(100); loadLevel(levelIdx + 1);
                    }
                } else {
                    player.x = nx; player.y = ny;
                    Audio.step();
                }
            }
        }

        window.addEventListener("keydown", (e) => {
            let dx = 0, dy = 0;
            if (e.key === "ArrowLeft") dx = -1;
            if (e.key === "ArrowRight") dx = 1;
            if (e.key === "ArrowUp") dy = -1;
            if (e.key === "ArrowDown") dy = 1;
            handleInput(dx, dy);
        });

        const UI = document.getElementById("ui-layer");
        const INPUT = document.getElementById("answer");

        function openUI(title, text, isBattle) {
            isPaused = true;
            UI.style.display = "block";
            document.getElementById("ui-title").innerText = title;
            document.getElementById("ui-text").innerText = text;
            document.getElementById("feedback").innerText = "";
            INPUT.value = "";
            if (isBattle) {
                document.getElementById("battle-ui").style.display = "block";
                document.getElementById("close-btn").style.display = "none";
                setTimeout(() => INPUT.focus(), 100);
            } else {
                document.getElementById("battle-ui").style.display = "none";
                document.getElementById("close-btn").style.display = "inline-block";
            }
        }

        function closeUI() { UI.style.display = "none"; isPaused = false; }

        window.checkAnswer = function() {
            if (!currentEnemy) return;
            const attempt = INPUT.value.toLowerCase().trim();
            const correct = currentEnemy.quest.a.toLowerCase().trim();
            if (attempt === correct) {
                Audio.magic();
                createParticles(currentEnemy.x, currentEnemy.y, "#a29bfe", 20);
                if (currentEnemy.type === "$") {
                    items = items.filter(i => i !== currentEnemy);
                    addScore(500);
                    closeUI();
                    setTimeout(() => { alert("BOSS DEFEATED! YOU WIN!"); location.reload(); }, 500);
                    return;
                }
                items = items.filter(i => i !== currentEnemy);
                addScore(50);
                closeUI();
            } else {
                Audio.error();
                shake = 5;
                document.getElementById("feedback").innerText = "WRONG! Try again.";
            }
        }

        INPUT.addEventListener("keypress", (e) => { if (e.key === "Enter") checkAnswer(); });
        
        function resize() { 
            CANVAS.width = window.innerWidth; 
            CANVAS.height = window.innerHeight; 
            CTX.imageSmoothingEnabled = false; // VITAL FOR CRISP PIXELS
            if(assetsLoaded === totalAssets) draw(); 
        }
        window.addEventListener('resize', resize);
        window.closeUI = closeUI;

    </script>
</body>
</html>
