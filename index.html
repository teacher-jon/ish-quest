<!DOCTYPE html>
<html>
<head>
    <title>Suffixia: Raw Engine</title>
    <style>
        body { margin: 0; background: #222; overflow: hidden; font-family: monospace; color: white; }
        canvas { display: block; margin: 0 auto; background: #111; border: 2px solid #555; }
        
        /* UI OVERLAY */
        #ui-layer {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: white; color: black; padding: 20px; border: 4px solid black;
            text-align: center; display: none; font-family: sans-serif;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
        input { padding: 5px; font-size: 16px; text-align: center; }
        button { padding: 8px 16px; font-size: 16px; cursor: pointer; background: #333; color: white; border: none; margin-top: 10px;}
        
        #debug { position: absolute; top: 10px; left: 10px; color: #0f0; font-size: 14px; pointer-events: none; }
    </style>
</head>
<body>

    <div id="debug">Status: Ready (Click screen to focus)</div>
    <canvas id="gameCanvas" width="800" height="600"></canvas>

    <div id="ui-layer">
        <h2 id="ui-title">Quest</h2>
        <p id="ui-text">...</p>
        <div id="battle-ui" style="display:none">
            <input type="text" id="answer" placeholder="Type -ish word">
            <br><button onclick="checkAnswer()">Attack</button>
        </div>
        <button id="close-btn" onclick="closeUI()" style="display:none">Close</button>
        <p id="feedback" style="color:red; font-weight:bold;"></p>
    </div>

    <script>
        // --- CONFIGURATION ---
        const TILE_SIZE = 32;
        const CANVAS = document.getElementById("gameCanvas");
        const CTX = CANVAS.getContext("2d");
        const DEBUG = document.getElementById("debug");
        
        // Colors
        const COLORS = {
            "#": "#666", // Wall
            ".": "#223", // Floor
            "@": "#33f", // Hero (Blue)
            "N": "#3f3", // NPC (Green)
            ">": "#ff0", // Stairs (Yellow)
            "E": "#f33", // Enemy (Red)
        };

        // Game State
        let player = { x: 5, y: 5 };
        let levelIdx = 0;
        let isPaused = false;
        let currentEnemy = null;

        // Level Map
        const LEVEL_MAP = [
            "####################",
            "#..................#",
            "#..N....#..........#",
            "#.......#....E.....#",
            "#.......#..........#",
            "#...#.......@......#",
            "#...#..............#",
            "#...#........>.....#",
            "#...#..............#",
            "####################"
        ];

        // Parsed Map Data
        let walls = [];
        let items = [];

        function loadLevel() {
            walls = [];
            items = [];
            
            for (let y = 0; y < LEVEL_MAP.length; y++) {
                let row = LEVEL_MAP[y];
                for (let x = 0; x < row.length; x++) {
                    let char = row[x];
                    
                    if (char === "#") {
                        walls.push({x, y});
                    } else if (char === "@") {
                        player.x = x;
                        player.y = y;
                    } else if (char !== ".") {
                        // Store NPC, Enemy, Stairs
                        items.push({x, y, type: char, id: Math.random()}); // ID for unique enemies
                    }
                }
            }
            draw();
        }

        // --- INPUT HANDLING ---
        window.addEventListener("keydown", (e) => {
            if (isPaused) return;

            let dx = 0; 
            let dy = 0;

            if (e.key === "ArrowLeft") dx = -1;
            if (e.key === "ArrowRight") dx = 1;
            if (e.key === "ArrowUp") dy = -1;
            if (e.key === "ArrowDown") dy = 1;

            if (dx !== 0 || dy !== 0) {
                DEBUG.innerText = `Key: ${e.key} | Moving...`;
                move(dx, dy);
            }
        });

        function move(dx, dy) {
            let nextX = player.x + dx;
            let nextY = player.y + dy;

            // 1. Check Walls
            if (isWall(nextX, nextY)) {
                DEBUG.innerText = "Blocked by Wall";
                return;
            }

            // 2. Check Items/Enemies
            let item = getItem(nextX, nextY);
            if (item) {
                handleInteraction(item);
                return; // Don't walk onto the item
            }

            // 3. Move
            player.x = nextX;
            player.y = nextY;
            draw();
        }

        function isWall(x, y) {
            return walls.some(w => w.x === x && w.y === y);
        }

        function getItem(x, y) {
            return items.find(i => i.x === x && i.y === y);
        }

        // --- INTERACTIONS ---
        function handleInteraction(item) {
            if (item.type === "N") {
                openUI("Wizard", "Combine words with '-ish' to defeat enemies!", false);
            } else if (item.type === "E") {
                currentEnemy = item;
                openUI("Battle!", "The ghost looks sickly pale green...", true);
            } else if (item.type === ">") {
                alert("You Win! Level Complete.");
                location.reload();
            }
        }

        // --- DRAWING ---
        function draw() {
            // Clear Screen
            CTX.fillStyle = "#111";
            CTX.fillRect(0, 0, CANVAS.width, CANVAS.height);

            // Center Camera logic (Simplified)
            let offsetX = 400 - (player.x * TILE_SIZE);
            let offsetY = 300 - (player.y * TILE_SIZE);

            CTX.save();
            CTX.translate(offsetX, offsetY);

            // Draw Walls & Floor
            for (let y = 0; y < LEVEL_MAP.length; y++) {
                for (let x = 0; x < LEVEL_MAP[y].length; x++) {
                    let char = LEVEL_MAP[y][x];
                    if (char === "#") drawTile(x, y, COLORS["#"]);
                    else drawTile(x, y, COLORS["."]);
                }
            }

            // Draw Items
            items.forEach(item => {
                let color = item.type === "E" ? COLORS["E"] : 
                            item.type === "N" ? COLORS["N"] : COLORS[">"];
                drawTile(item.x, item.y, color);
            });

            // Draw Player
            drawTile(player.x, player.y, COLORS["@"]);

            CTX.restore();
        }

        function drawTile(x, y, color) {
            CTX.fillStyle = color;
            CTX.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE - 2, TILE_SIZE - 2);
        }

        // --- UI LOGIC ---
        const UI = document.getElementById("ui-layer");
        const TITLE = document.getElementById("ui-title");
        const TEXT = document.getElementById("ui-text");
        const INPUT = document.getElementById("answer");
        const BATTLE = document.getElementById("battle-ui");
        const CLOSE = document.getElementById("close-btn");

        function openUI(title, text, isBattle) {
            isPaused = true;
            UI.style.display = "block";
            TITLE.innerText = title;
            TEXT.innerText = text;
            document.getElementById("feedback").innerText = "";
            
            if (isBattle) {
                BATTLE.style.display = "block";
                CLOSE.style.display = "none";
                setTimeout(() => INPUT.focus(), 100);
            } else {
                BATTLE.style.display = "none";
                CLOSE.style.display = "inline-block";
            }
        }

        function closeUI() {
            UI.style.display = "none";
            isPaused = false;
        }

        window.checkAnswer = function() {
            if (INPUT.value.includes("ish")) {
                // Kill Enemy
                items = items.filter(i => i !== currentEnemy);
                closeUI();
                draw();
            } else {
                document.getElementById("feedback").innerText = "Wrong! Try adding -ish";
            }
        }

        window.closeUI = closeUI;

        // START
        loadLevel();

    </script>
</body>
</html>
