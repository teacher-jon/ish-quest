<!DOCTYPE html>
<html>
<head>
    <title>Suffixia: Unlocked Edition</title>
    <style>
        body { 
            margin: 0; 
            background: #050505; 
            overflow: hidden; 
            font-family: 'Verdana', sans-serif; 
            color: white; 
        }
        
        canvas { 
            display: block; 
            background: #000; 
        }
        
        /* HUD (Heads Up Display) */
        #hud {
            position: absolute; top: 10px; left: 10px;
            background: rgba(0,0,0,0.7); padding: 10px; border-radius: 8px;
            border: 1px solid #444; pointer-events: none;
            display: flex; gap: 20px; font-size: 20px; font-weight: bold;
        }
        .hud-item { display: flex; align-items: center; gap: 8px; }

        /* UI OVERLAY */
        #ui-layer {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(20, 20, 30, 0.98); 
            color: #eee; 
            padding: 40px; 
            border: 3px solid #6c5ce7;
            border-radius: 15px;
            text-align: center; 
            display: none; 
            width: 550px;
            box-shadow: 0 0 80px rgba(108, 92, 231, 0.5);
        }

        h2#ui-title { margin-top: 0; color: #a29bfe; text-transform: uppercase; letter-spacing: 2px; border-bottom: 2px solid #444; padding-bottom: 15px;}
        p#ui-text { font-size: 20px; line-height: 1.6; margin: 20px 0; }

        input { 
            padding: 15px; font-size: 22px; text-align: center; width: 80%; margin-top: 15px;
            background: #2d3436; border: 2px solid #636e72; color: white; border-radius: 8px; outline: none;
        }
        input:focus { border-color: #a29bfe; }
        
        button { 
            padding: 12px 30px; font-size: 18px; cursor: pointer; margin-top: 25px;
            background: #6c5ce7; color: white; border: none; border-radius: 8px; font-weight: bold;
            transition: all 0.2s;
        }
        button:hover { background: #81ecec; color: black; transform: scale(1.05); }
        
        #loading { 
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
            font-size: 24px; font-weight: bold; color: #a29bfe; letter-spacing: 4px;
        }
    </style>
</head>
<body>

    <div id="loading">GENERATING DUNGEON...</div>
    
    <div id="hud">
        <div class="hud-item">ðŸ”‘ <span id="key-count">0</span></div>
        <div class="hud-item">ðŸ§ª <span id="potion-status">OFF</span></div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <h2 id="ui-title">Quest</h2>
        <p id="ui-text">...</p>
        
        <div id="battle-ui" style="display:none">
            <input type="text" id="answer" placeholder="Type answer..." autocomplete="off">
            <br>
            <button onclick="checkAnswer()">CAST SPELL</button>
        </div>
        
        <button id="close-btn" onclick="closeUI()" style="display:none">CONTINUE</button>
        <p id="feedback" style="color:#ff7675; font-weight:bold; min-height: 20px; margin-top:15px;"></p>
    </div>

    <script>
        // --- 1. CONFIGURATION ---
        const TILE_SIZE = 64; 
        const CANVAS = document.getElementById("gameCanvas");
        const CTX = CANVAS.getContext("2d");

        // --- 2. ASSETS & GRAPHICS ---
        const ASSETS = {
            "@": "images/hero.png",
            "#": "images/wall.png",
            ".": "images/floor.png",
            "N": "images/npc.png",
            ">": "images/stairs.png",
            "E": "images/enemy.png",
            "$": "images/boss.png"
        };

        const IMAGES = {};
        let assetsLoaded = 0;
        const totalAssets = Object.keys(ASSETS).length;

        function preloadImages() {
            for (let key in ASSETS) {
                const img = new Image();
                img.src = ASSETS[key];
                img.onload = () => { assetsLoaded++; checkLoad(); };
                img.onerror = () => { assetsLoaded++; checkLoad(); };
                IMAGES[key] = img;
            }
        }
        function checkLoad() {
            if (assetsLoaded === totalAssets) {
                document.getElementById("loading").style.display = "none";
                resize();
                requestAnimationFrame(gameLoop);
            }
        }

        // --- 3. QUESTION BANK ---
        const REGULAR_QUESTIONS = [
            { a: "greenish", q: "Somewhat green." }, { a: "boyish", q: "Like a boy." },
            { a: "girlish", q: "Like a girl." }, { a: "childish", q: "Immature; like a child." },
            { a: "ticklish", q: "Sensitive to tickling." }, { a: "feverish", q: "Having a fever." },
            { a: "stylish", q: "Fashionable." }, { a: "foolish", q: "Lacking sense." },
            { a: "selfish", q: "Caring only for self." }, { a: "pinkish", q: "Slightly pink." },
            { a: "sweetish", q: "Somewhat sweet." }, { a: "tallish", q: "Somewhat tall." },
            { a: "darkish", q: "Somewhat dark." }, { a: "coldish", q: "Slightly cold." },
            { a: "oldish", q: "Somewhat old." }, { a: "youngish", q: "Somewhat young." },
            { a: "wildish", q: "Somewhat wild." }, { a: "dampish", q: "Slightly wet." },
            { a: "warmish", q: "Slightly warm." }, { a: "slowish", q: "Somewhat slow." },
            { a: "fastish", q: "Somewhat fast." }, { a: "flatish", q: "Somewhat flat." },
            { a: "roundish", q: "Somewhat round." }, { a: "shortish", q: "Somewhat short." },
            { a: "longish", q: "Somewhat long." }, { a: "goodish", q: "Fairly good." },
            { a: "badish", q: "Somewhat bad." }, { a: "hardish", q: "Somewhat hard." },
            { a: "softish", q: "Somewhat soft." }, { a: "sheepish", q: "Embarrassed or shy." },
            { a: "bookish", q: "Fond of reading." }, { a: "owlishes", q: "Wise like an owl." },
            { a: "modish", q: "Trendy." }, { a: "sluggish", q: "Slow-moving." },
            { a: "peckish", q: "Hungry." }, { a: "squeamish", q: "Easily nauseated." },
            { a: "clownish", q: "Funny or silly." }, { a: "waspish", q: "Angry or irritable." }
        ];

        const BOSS_QUESTIONS = [
            { a: "adjective", q: "Does the suffix '-ish' turn a noun into a Verb or Adjective?" },
            { a: "quality of", q: "Does '-ish' mean 'without' or 'having the quality of'?" },
            { a: "noun", q: "To make 'Foolish', do you add -ish to a Noun or Verb?" },
            { a: "somewhat", q: "In 'Greenish', does it mean 'very' or 'somewhat'?" },
            { a: "approximation", q: "In 'Seven-ish', does it imply precision or approximation?" }
        ];

        // --- 4. GAME STATE ---
        let player = { x: 1, y: 1 };
        let inventory = { keys: 0, vision: false };
        let levelIdx = 0;
        let isPaused = false;
        let currentEnemy = null;
        let walls = [];
        let items = [];
        let moveTimer = 0;

        // --- 5. LEVEL DESIGN (FIXED!) ---
        // K = Key, D = Locked Door, P = Potion, S = Secret Wall (Walkable), H = Hidden Trap
        const LEVELS = [
            // LEVEL 1: FIXED - Key is now in the top room, accessible immediately
            [
                "####################",
                "#@.......E....K....#", // Start, Enemy, KEY IS HERE NOW
                "#.N...H............#", 
                "#######D############", // Locked Door blocks the exit, but you have the key now
                "#...........E......#", 
                "#...P.......#......#", 
                "#...#.......E......#",
                "#...#...E....>.....#",
                "#...#..............#",
                "####################"
            ],
            // LEVEL 2: The Whispering Halls
            [
                "#######################",
                "#@..E...#...E....D....#",
                "#.......#.......###...#",
                "###.#####...#####K#...#", // Key tucked away
                "#.......E.......#.....#",
                "#.N........H....#.....#",
                "#########S#######.....#", // Secret Wall shortcut
                "#..E........#...E.....#",
                "#K.....H....#...>.....#", // Another key
                "#######################"
            ],
            // LEVEL 3: The Boss Dungeon
            [
                "#######################",
                "#.....................#",
                "#.@.#####D#######.K...#",
                "#...#...#...#...#.....#",
                "#...E...S...E...#.....#", 
                "#...#...#...#...#.....#",
                "#.......#$#.....E.....#", // Boss Guarded
                "#.......#D#...........#", 
                "#.........H...........#",
                "#######################"
            ]
        ];

        function loadLevel(idx) {
            levelIdx = idx;
            if (levelIdx >= LEVELS.length) {
                alert("YOU HAVE CONQUERED SUFFIXIA!");
                levelIdx = 0;
                inventory = { keys: 0, vision: false }; 
            }

            const map = LEVELS[levelIdx];
            walls = [];
            items = [];

            for (let y = 0; y < map.length; y++) {
                for (let x = 0; x < map[y].length; x++) {
                    let char = map[y][x];
                    
                    if (char === "#") walls.push({x, y});
                    else if (char === "@") { player.x = x; player.y = y; }
                    else if (char === "E" || char === "$" || char === "H") {
                        let pool = (char === "$") ? BOSS_QUESTIONS : REGULAR_QUESTIONS;
                        let qData = pool[Math.floor(Math.random() * pool.length)];
                        items.push({ 
                            x, y, type: char, quest: qData, id: Math.random(),
                            isMoving: (char === "E") 
                        });
                    } 
                    else if ("KDP>NS".includes(char)) {
                        items.push({ x, y, type: char, id: Math.random() });
                    }
                }
            }
            updateHUD();
        }

        function updateHUD() {
            document.getElementById("key-count").innerText = inventory.keys;
            document.getElementById("potion-status").innerText = inventory.vision ? "ON" : "OFF";
            document.getElementById("potion-status").style.color = inventory.vision ? "#55efc4" : "#636e72";
        }

        // --- 6. GAME LOOP ---
        function gameLoop() {
            if(!isPaused) {
                updateEnemies();
                draw();
            }
            requestAnimationFrame(gameLoop);
        }

        function updateEnemies() {
            moveTimer++;
            if (moveTimer > 80) { // Slower movement
                moveTimer = 0;
                items.forEach(item => {
                    if (item.isMoving) {
                        let dirs = [[0,1], [0,-1], [1,0], [-1,0]];
                        let move = dirs[Math.floor(Math.random() * dirs.length)];
                        let nx = item.x + move[0];
                        let ny = item.y + move[1];
                        if (!isWall(nx, ny) && !isPlayer(nx, ny) && !isItem(nx, ny)) {
                            item.x = nx;
                            item.y = ny;
                        }
                    }
                });
            }
        }

        function isWall(x, y) { return walls.some(w => w.x === x && w.y === y); }
        function isPlayer(x, y) { return player.x === x && player.y === y; }
        function isItem(x, y) { return items.some(i => i.x === x && i.y === y); }

        // --- 7. DRAWING ---
        function draw() {
            CANVAS.width = window.innerWidth;
            CANVAS.height = window.innerHeight;
            CTX.imageSmoothingEnabled = false;

            CTX.fillStyle = "#050505";
            CTX.fillRect(0, 0, CANVAS.width, CANVAS.height);

            let offsetX = (CANVAS.width / 2) - (player.x * TILE_SIZE) - (TILE_SIZE / 2);
            let offsetY = (CANVAS.height / 2) - (player.y * TILE_SIZE) - (TILE_SIZE / 2);

            CTX.save();
            CTX.translate(offsetX, offsetY);

            // Draw Map
            const map = LEVELS[levelIdx];
            for (let y = 0; y < map.length; y++) {
                for (let x = 0; x < map[y].length; x++) {
                    let char = map[y][x];
                    drawTile(x, y, ".", 0); // Floor base
                    if (char === "#") drawTile(x, y, "#", 0);
                }
            }

            // Draw Items
            const bob = Math.sin(Date.now() / 200) * 5;
            items.forEach(item => {
                if (item.type === "H" && !inventory.vision) {
                    // Invisible trap!
                } else if (item.type === "S") {
                    drawTile(item.x, item.y, "S", 0); // Secret wall visual
                } else {
                    let yOffset = (item.type === "E" || item.type === "N" || item.type === "$") ? bob : 0;
                    drawTile(item.x, item.y, item.type, yOffset);
                }
            });

            // Draw Player
            drawTile(player.x, player.y, "@", bob);

            CTX.restore();
        }

        function drawTile(x, y, type, yOffset) {
            const px = x * TILE_SIZE;
            const py = (y * TILE_SIZE) + yOffset;
            const img = IMAGES[type];

            // 1. Draw Images
            if (img && img.complete && img.naturalHeight !== 0) {
                CTX.drawImage(img, px, py, TILE_SIZE, TILE_SIZE);
                return;
            } 
            
            // 2. Draw Code-Generated Items
            if (type === "#") { CTX.fillStyle = "#444"; CTX.fillRect(px, py, TILE_SIZE, TILE_SIZE); return; }
            if (type === ".") { CTX.fillStyle = "#111"; CTX.fillRect(px, py, TILE_SIZE, TILE_SIZE); return; }
            
            // Special Items with Emojis
            CTX.font = (TILE_SIZE * 0.7) + "px Arial";
            CTX.textAlign = "center";
            CTX.textBaseline = "middle";
            let cx = px + TILE_SIZE/2;
            let cy = py + TILE_SIZE/2;

            if (type === "K") { CTX.fillText("ðŸ”‘", cx, cy); }
            else if (type === "D") { CTX.fillStyle = "#a65c00"; CTX.fillRect(px, py, TILE_SIZE, TILE_SIZE); CTX.fillStyle="white"; CTX.fillText("ðŸ”’", cx, cy); }
            else if (type === "P") { CTX.fillText("ðŸ§ª", cx, cy); }
            else if (type === "S") { CTX.fillStyle = "#333"; CTX.fillRect(px, py, TILE_SIZE, TILE_SIZE); CTX.fillStyle="#555"; CTX.fillText("?", cx, cy); } // Secret Wall
            else if (type === "H") { CTX.fillText("âš ï¸", cx, cy); } // Visible trap
            else if (type === "@") { CTX.fillStyle = "#6c5ce7"; CTX.fillRect(px, py, TILE_SIZE, TILE_SIZE); }
            else if (type === "E") { CTX.fillStyle = "#d63031"; CTX.fillRect(px, py, TILE_SIZE, TILE_SIZE); }
            else if (type === ">") { CTX.fillStyle = "#ffeaa7"; CTX.fillRect(px, py, TILE_SIZE, TILE_SIZE); }
            else { CTX.fillStyle = "green"; CTX.fillRect(px, py, TILE_SIZE, TILE_SIZE); }
        }

        // --- 8. MOVEMENT & INTERACTION ---
        window.addEventListener("keydown", (e) => {
            if (isPaused) return;
            let dx = 0, dy = 0;
            if (e.key === "ArrowLeft") dx = -1;
            if (e.key === "ArrowRight") dx = 1;
            if (e.key === "ArrowUp") dy = -1;
            if (e.key === "ArrowDown") dy = 1;

            if (dx !== 0 || dy !== 0) {
                let nx = player.x + dx;
                let ny = player.y + dy;

                if (isWall(nx, ny)) return; // Solid wall

                let item = items.find(i => i.x === nx && i.y === ny);
                
                if (item) {
                    if (item.type === "N") {
                        openUI("Wizard", "I heard there is a Key hidden in this very room!", false);
                    } 
                    else if (item.type === "K") {
                        inventory.keys++;
                        updateHUD();
                        items = items.filter(i => i !== item); 
                        player.x = nx; player.y = ny;
                    }
                    else if (item.type === "P") {
                        inventory.vision = true;
                        updateHUD();
                        openUI("Potion Drinker", "You can now see hidden traps!", false);
                        items = items.filter(i => i !== item); 
                        player.x = nx; player.y = ny;
                    }
                    else if (item.type === "D") {
                        if (inventory.keys > 0) {
                            inventory.keys--;
                            updateHUD();
                            items = items.filter(i => i !== item); // Open Door
                            openUI("Unlocked!", "You used a key to open the door.", false);
                        } else {
                            openUI("Locked", "You need a key ðŸ”‘ to open this door.", false);
                        }
                    }
                    else if (item.type === "S") {
                        // Secret wall - just walk through!
                        player.x = nx; player.y = ny;
                    }
                    else if (item.type === "E" || item.type === "$" || item.type === "H") {
                        currentEnemy = item;
                        let title = (item.type === "$") ? "BOSS BATTLE" : (item.type === "H" ? "SURPRISE!" : "Battle");
                        openUI(title, item.quest.q, true);
                    } 
                    else if (item.type === ">") {
                        loadLevel(levelIdx + 1);
                    }
                } else {
                    player.x = nx;
                    player.y = ny;
                }
            }
        });

        // --- 9. UI LOGIC ---
        const UI = document.getElementById("ui-layer");
        const INPUT = document.getElementById("answer");

        function openUI(title, text, isBattle) {
            isPaused = true;
            UI.style.display = "block";
            document.getElementById("ui-title").innerText = title;
            document.getElementById("ui-text").innerText = text;
            document.getElementById("feedback").innerText = "";
            INPUT.value = "";

            if (isBattle) {
                document.getElementById("battle-ui").style.display = "block";
                document.getElementById("close-btn").style.display = "none";
                setTimeout(() => INPUT.focus(), 100);
            } else {
                document.getElementById("battle-ui").style.display = "none";
                document.getElementById("close-btn").style.display = "inline-block";
            }
        }

        function closeUI() {
            UI.style.display = "none";
            isPaused = false;
        }

        window.checkAnswer = function() {
            if (!currentEnemy) return;
            const attempt = INPUT.value.toLowerCase().trim();
            const correct = currentEnemy.quest.a.toLowerCase().trim();
            if (attempt === correct) {
                items = items.filter(i => i !== currentEnemy);
                closeUI();
            } else {
                document.getElementById("feedback").innerText = "WRONG! Try again.";
            }
        }

        INPUT.addEventListener("keypress", (e) => {
            if (e.key === "Enter") checkAnswer();
        });
        
        function resize() {
            CANVAS.width = window.innerWidth;
            CANVAS.height = window.innerHeight;
            if(assetsLoaded === totalAssets) draw();
        }
        window.addEventListener('resize', resize);
        window.closeUI = closeUI;

        // START
        preloadImages();
        loadLevel(0);

    </script>
</body>
</html>
