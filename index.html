<!DOCTYPE html>
<html>
<head>
    <title>Suffixia: The Legend Returns</title>
    <style>
        body { margin: 0; background: #222; overflow: hidden; font-family: monospace; color: white; }
        canvas { display: block; margin: 0 auto; background: #151515; border: 2px solid #555; }
        
        /* UI OVERLAY */
        #ui-layer {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: white; color: black; padding: 20px; border: 4px solid black;
            text-align: center; display: none; font-family: sans-serif;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5); width: 300px;
        }
        input { padding: 5px; font-size: 16px; text-align: center; width: 80%; margin-top: 10px;}
        button { padding: 8px 16px; font-size: 16px; cursor: pointer; background: #333; color: white; border: none; margin-top: 10px;}
        button:hover { background: #555; }
        
        #debug { position: absolute; top: 10px; left: 10px; color: #0f0; font-size: 14px; pointer-events: none; }
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 24px; }
    </style>
</head>
<body>

    <div id="debug">Loading Assets...</div>
    <div id="loading">LOADING IMAGES...</div>
    <canvas id="gameCanvas" width="800" height="600"></canvas>

    <div id="ui-layer">
        <h2 id="ui-title">Quest</h2>
        <p id="ui-text">...</p>
        <div id="battle-ui" style="display:none">
            <input type="text" id="answer" placeholder="Type -ish word" autocomplete="off">
            <br><button onclick="checkAnswer()">Cast Spell</button>
        </div>
        <button id="close-btn" onclick="closeUI()" style="display:none">Close</button>
        <p id="feedback" style="color:red; font-weight:bold; min-height: 20px; margin-top:10px;"></p>
    </div>

    <script>
        // --- 1. CONFIGURATION ---
        const TILE_SIZE = 48; // Bigger tiles for better detail
        const CANVAS = document.getElementById("gameCanvas");
        const CTX = CANVAS.getContext("2d");
        const DEBUG = document.getElementById("debug");

        // --- 2. IMAGE LOADER ---
        // Maps the map characters to your file names
        const ASSETS = {
            "@": "images/hero.png",
            "#": "images/wall.png",
            ".": "images/floor.png",
            "N": "images/npc.png",
            ">": "images/stairs.png",
            "E": "images/enemy.png",
            "$": "images/boss.png"
        };

        const IMAGES = {};
        let assetsLoaded = 0;
        const totalAssets = Object.keys(ASSETS).length;

        function preloadImages() {
            for (let key in ASSETS) {
                const img = new Image();
                img.src = ASSETS[key];
                img.onload = () => {
                    assetsLoaded++;
                    checkLoad();
                };
                img.onerror = () => {
                    console.error("Failed to load: " + ASSETS[key]);
                    // If image fails, we still count it so game starts (it will show as colored square)
                    assetsLoaded++;
                    checkLoad();
                };
                IMAGES[key] = img;
            }
        }

        function checkLoad() {
            if (assetsLoaded === totalAssets) {
                document.getElementById("loading").style.display = "none";
                DEBUG.innerText = "Assets Loaded. Starting...";
                loadLevel(0);
            }
        }

        // --- 3. GAME DATA ---
        let player = { x: 1, y: 1 };
        let levelIdx = 0;
        let isPaused = false;
        let currentEnemy = null;
        let walls = [];
        let items = [];

        const LEVELS = [
            // LEVEL 1: The Village
            [
                "####################",
                "#..................#",
                "#.N................#",
                "#.......#....E.....#",
                "#.......#..........#",
                "#...#.......@......#",
                "#...#..............#",
                "#...#........>.....#",
                "#...#..............#",
                "####################"
            ],
            // LEVEL 2: The Forest
            [
                "####################",
                "#@..E...#...E......#",
                "#.......#.......#..#",
                "###.#####...#####..#",
                "#.......E.......#..#",
                "#.N.............#..#",
                "#########...#####..#",
                "#...........#......#",
                "#...........#...>..#",
                "####################"
            ],
            // LEVEL 3: The Dungeon
            [
                "####################",
                "#..................#",
                "#.@.#...#...#...#..#",
                "#...#...#...#...#..#",
                "#...E.......E......#",
                "#..................#",
                "#.........$........#",
                "#..................#",
                "#..................#",
                "####################"
            ]
        ];

        const QUESTS = {
            "greenish": { clue: "Sickly pale color...", answer: "greenish" },
            "boyish": { clue: "Grown man, young face...", answer: "boyish" },
            "ticklish": { clue: "Laughs when feet touched...", answer: "ticklish" },
            "stylish": { clue: "Wears trendy clothes...", answer: "stylish" },
            "squeamish": { clue: "Faints at sight of blood...", answer: "squeamish" }
        };

        // --- 4. ENGINE LOGIC ---

        function loadLevel(idx) {
            levelIdx = idx;
            if (levelIdx >= LEVELS.length) {
                alert("YOU WIN! GAME OVER.");
                levelIdx = 0;
            }

            const map = LEVELS[levelIdx];
            walls = [];
            items = [];

            // Parse Map
            for (let y = 0; y < map.length; y++) {
                for (let x = 0; x < map[y].length; x++) {
                    let char = map[y][x];
                    
                    if (char === "#") {
                        walls.push({x, y});
                    } else if (char === "@") {
                        player.x = x;
                        player.y = y;
                    } else if (char === "E" || char === "$") {
                        // Pick a random quest for this enemy
                        const keys = Object.keys(QUESTS);
                        const questKey = keys[Math.floor(Math.random() * keys.length)];
                        items.push({ x, y, type: char, quest: QUESTS[questKey], id: Math.random() });
                    } else if (char !== ".") {
                        items.push({ x, y, type: char, id: Math.random() });
                    }
                }
            }
            DEBUG.innerText = "Level " + (levelIdx + 1);
            draw();
        }

        function draw() {
            // Clear Background
            CTX.fillStyle = "#151515";
            CTX.fillRect(0, 0, CANVAS.width, CANVAS.height);

            // Camera: Keep player centered
            let offsetX = (CANVAS.width / 2) - (player.x * TILE_SIZE) - (TILE_SIZE / 2);
            let offsetY = (CANVAS.height / 2) - (player.y * TILE_SIZE) - (TILE_SIZE / 2);

            CTX.save();
            CTX.translate(offsetX, offsetY);

            // 1. Draw Map Tiles
            const map = LEVELS[levelIdx];
            for (let y = 0; y < map.length; y++) {
                for (let x = 0; x < map[y].length; x++) {
                    let char = map[y][x];
                    // Always draw floor first
                    drawTile(x, y, ".");
                    
                    if (char === "#") {
                        drawTile(x, y, "#");
                    }
                }
            }

            // 2. Draw Items
            items.forEach(item => {
                drawTile(item.x, item.y, item.type);
            });

            // 3. Draw Player
            drawTile(player.x, player.y, "@");

            CTX.restore();
        }

        function drawTile(x, y, type) {
            const img = IMAGES[type];
            if (img && img.complete && img.naturalHeight !== 0) {
                // FORCE IMAGE TO FIT TILE_SIZE (Fixes the big image bug!)
                CTX.drawImage(img, x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
            } else {
                // Fallback colored square if image missing
                if (type === "#") CTX.fillStyle = "#555";
                else if (type === ".") CTX.fillStyle = "#222";
                else if (type === "@") CTX.fillStyle = "blue";
                else if (type === "E") CTX.fillStyle = "red";
                else if (type === ">") CTX.fillStyle = "yellow";
                else CTX.fillStyle = "green";
                
                CTX.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
            }
        }

        // --- 5. MOVEMENT & INTERACTION ---

        window.addEventListener("keydown", (e) => {
            if (isPaused) return;

            let dx = 0, dy = 0;
            if (e.key === "ArrowLeft") dx = -1;
            if (e.key === "ArrowRight") dx = 1;
            if (e.key === "ArrowUp") dy = -1;
            if (e.key === "ArrowDown") dy = 1;

            if (dx !== 0 || dy !== 0) move(dx, dy);
        });

        function move(dx, dy) {
            let nextX = player.x + dx;
            let nextY = player.y + dy;

            // Collision: Walls
            if (walls.some(w => w.x === nextX && w.y === nextY)) return;

            // Collision: Items
            let item = items.find(i => i.x === nextX && i.y === nextY);
            if (item) {
                handleItem(item);
                return; // Stop moving if we hit something
            }

            player.x = nextX;
            player.y = nextY;
            draw();
        }

        function handleItem(item) {
            if (item.type === "N") {
                openUI("Wizard", "Combine the base word with '-ish' to defeat the monsters!", false);
            } else if (item.type === "E" || item.type === "$") {
                currentEnemy = item;
                openUI("Battle Mode", item.quest.clue, true);
            } else if (item.type === ">") {
                loadLevel(levelIdx + 1);
            }
        }

        // --- 6. UI SYSTEM ---

        const UI = document.getElementById("ui-layer");
        const INPUT = document.getElementById("answer");

        function openUI(title, text, isBattle) {
            isPaused = true;
            UI.style.display = "block";
            document.getElementById("ui-title").innerText = title;
            document.getElementById("ui-text").innerText = text;
            document.getElementById("feedback").innerText = "";
            INPUT.value = "";

            if (isBattle) {
                document.getElementById("battle-ui").style.display = "block";
                document.getElementById("close-btn").style.display = "none";
                setTimeout(() => INPUT.focus(), 100);
            } else {
                document.getElementById("battle-ui").style.display = "none";
                document.getElementById("close-btn").style.display = "inline-block";
            }
        }

        function closeUI() {
            UI.style.display = "none";
            isPaused = false;
        }

        window.checkAnswer = function() {
            if (!currentEnemy) return;
            
            const attempt = INPUT.value.toLowerCase().trim();
            if (attempt === currentEnemy.quest.answer) {
                // Defeat Enemy
                items = items.filter(i => i !== currentEnemy);
                closeUI();
                draw();
            } else {
                document.getElementById("feedback").innerText = "Wrong! Try again.";
            }
        }

        // Handle Enter Key in Input
        INPUT.addEventListener("keypress", (e) => {
            if (e.key === "Enter") checkAnswer();
        });
        
        // Expose CloseUI globally
        window.closeUI = closeUI;

        // START ENGINE
        preloadImages();

    </script>
</body>
</html>
