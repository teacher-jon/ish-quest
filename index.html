<!DOCTYPE html>
<html>
<head>
    <title>Suffixia: Final Cut</title>
    <style>
        body { 
            margin: 0; 
            background: #050505; 
            overflow: hidden; 
            font-family: 'Verdana', sans-serif; 
            color: white; 
            user-select: none;
        }
        
        canvas { 
            display: block; 
            background: #000; 
        }
        
        /* HUD */
        #hud {
            position: absolute; top: 10px; left: 10px;
            background: rgba(0,0,0,0.8); padding: 10px 20px; border-radius: 8px;
            border: 2px solid #555; pointer-events: none;
            display: flex; gap: 20px; font-size: 20px; font-weight: bold;
            z-index: 10;
        }
        .hud-item { display: flex; align-items: center; gap: 8px; }

        /* START SCREEN (Required for Audio) */
        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); z-index: 200;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        #start-btn {
            padding: 20px 40px; font-size: 24px; font-weight: bold; 
            background: #6c5ce7; color: white; border: none; border-radius: 10px;
            cursor: pointer; box-shadow: 0 0 20px #6c5ce7;
            animation: pulse 2s infinite;
        }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.05); } 100% { transform: scale(1); } }

        /* QUEST POPUP */
        #ui-layer {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(20, 20, 30, 0.98); 
            color: #eee; 
            padding: 40px; 
            border: 3px solid #6c5ce7;
            border-radius: 15px;
            text-align: center; 
            display: none; 
            width: 550px;
            box-shadow: 0 0 80px rgba(108, 92, 231, 0.5);
            z-index: 100;
        }

        h2#ui-title { margin-top: 0; color: #a29bfe; text-transform: uppercase; letter-spacing: 2px; border-bottom: 2px solid #444; padding-bottom: 15px;}
        p#ui-text { font-size: 20px; line-height: 1.6; margin: 20px 0; }

        input { 
            padding: 15px; font-size: 22px; text-align: center; width: 80%; margin-top: 15px;
            background: #2d3436; border: 2px solid #636e72; color: white; border-radius: 8px; outline: none;
        }
        input:focus { border-color: #a29bfe; }
        
        button { 
            padding: 12px 30px; font-size: 18px; cursor: pointer; margin-top: 25px;
            background: #6c5ce7; color: white; border: none; border-radius: 8px; font-weight: bold;
            transition: all 0.2s;
        }
        button:hover { background: #81ecec; color: black; transform: scale(1.05); }
    </style>
</head>
<body>

    <div id="start-screen">
        <h1>SUFFIXIA</h1>
        <button id="start-btn" onclick="startGame()">CLICK TO START GAME & MUSIC</button>
        <p style="color:#aaa; margin-top:20px;">(Headphones Recommended)</p>
    </div>
    
    <div id="hud">
        <div class="hud-item">ðŸ”‘ <span id="key-count">0</span></div>
        <div class="hud-item">ðŸ§ª <span id="potion-status">OFF</span></div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <h2 id="ui-title">Quest</h2>
        <p id="ui-text">...</p>
        
        <div id="battle-ui" style="display:none">
            <input type="text" id="answer" placeholder="Type answer..." autocomplete="off">
            <br>
            <button onclick="checkAnswer()">CAST SPELL</button>
        </div>
        
        <button id="close-btn" onclick="closeUI()" style="display:none">CONTINUE</button>
        <p id="feedback" style="color:#ff7675; font-weight:bold; min-height: 20px; margin-top:15px;"></p>
    </div>

    <script>
        // --- 1. CONFIGURATION ---
        const TILE_SIZE = 64; 
        const CANVAS = document.getElementById("gameCanvas");
        const CTX = CANVAS.getContext("2d");

        // --- 2. SOUND ENGINE (Polished) ---
        const Audio = {
            ctx: null,
            bgmNodes: [],
            
            init: function() {
                if (!this.ctx) {
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    this.ctx = new AudioContext();
                }
                if (this.ctx.state === 'suspended') {
                    this.ctx.resume();
                }
                this.startBGM();
            },

            playTone: function(freq, type, duration, vol=0.1) {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            },

            step: () => Audio.playTone(100, 'triangle', 0.05, 0.05),
            pickup: () => {
                Audio.playTone(600, 'sine', 0.1, 0.1);
                setTimeout(() => Audio.playTone(1200, 'sine', 0.3, 0.1), 100);
            },
            unlock: () => {
                Audio.playTone(200, 'sawtooth', 0.2, 0.1);
                setTimeout(() => Audio.playTone(400, 'sawtooth', 0.4, 0.1), 200);
            },
            magic: () => {
                if (!Audio.ctx) return;
                const osc = Audio.ctx.createOscillator();
                const gain = Audio.ctx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(400, Audio.ctx.currentTime);
                osc.frequency.linearRampToValueAtTime(1200, Audio.ctx.currentTime + 0.3);
                gain.gain.setValueAtTime(0.1, Audio.ctx.currentTime);
                gain.gain.linearRampToValueAtTime(0, Audio.ctx.currentTime + 0.3);
                osc.connect(gain);
                gain.connect(Audio.ctx.destination);
                osc.start();
                osc.stop(Audio.ctx.currentTime + 0.3);
            },
            error: () => Audio.playTone(100, 'sawtooth', 0.4, 0.1),
            win: () => {
                let notes = [523, 659, 784, 1046]; 
                notes.forEach((n, i) => setTimeout(() => Audio.playTone(n, 'square', 0.5, 0.1), i * 150));
            },

            startBGM: function() {
                // Prevent double playing
                if (this.bgmNodes.length > 0) return;
                
                // 1. Low Drone
                const osc1 = this.ctx.createOscillator();
                const g1 = this.ctx.createGain();
                osc1.frequency.value = 55; // A1
                osc1.type = 'triangle';
                g1.gain.value = 0.15; // Increased volume
                osc1.connect(g1);
                g1.connect(this.ctx.destination);
                osc1.start();

                // 2. Harmony (Fifth)
                const osc2 = this.ctx.createOscillator();
                const g2 = this.ctx.createGain();
                osc2.frequency.value = 82.41; // E2
                osc2.type = 'sine';
                g2.gain.value = 0.1;
                osc2.connect(g2);
                g2.connect(this.ctx.destination);
                osc2.start();

                this.bgmNodes.push(osc1, osc2);
            }
        };

        // --- 3. ASSETS ---
        const ASSETS = {
            "@": "images/hero.png",
            "#": "images/wall.png",
            ".": "images/floor.png",
            "N": "images/npc.png",
            ">": "images/stairs.png",
            "E": "images/enemy.png",
            "$": "images/boss.png"
        };
        const IMAGES = {};
        let assetsLoaded = 0;
        const totalAssets = Object.keys(ASSETS).length;

        function preloadImages() {
            for (let key in ASSETS) {
                const img = new Image();
                img.src = ASSETS[key];
                img.onload = () => { assetsLoaded++; };
                img.onerror = () => { assetsLoaded++; }; // Fail silently, use fallback
                IMAGES[key] = img;
            }
        }
        
        // --- 4. QUESTION BANK ---
        const REGULAR_QUESTIONS = [
            { a: "greenish", q: "Somewhat green." }, { a: "boyish", q: "Like a boy." },
            { a: "girlish", q: "Like a girl." }, { a: "childish", q: "Immature; like a child." },
            { a: "ticklish", q: "Sensitive to tickling." }, { a: "feverish", q: "Having a fever." },
            { a: "stylish", q: "Fashionable." }, { a: "foolish", q: "Lacking sense." },
            { a: "selfish", q: "Caring only for self." }, { a: "pinkish", q: "Slightly pink." },
            { a: "sweetish", q: "Somewhat sweet." }, { a: "tallish", q: "Somewhat tall." },
            { a: "darkish", q: "Somewhat dark." }, { a: "coldish", q: "Slightly cold." },
            { a: "oldish", q: "Somewhat old." }, { a: "youngish", q: "Somewhat young." },
            { a: "wildish", q: "Somewhat wild." }, { a: "dampish", q: "Slightly wet." },
            { a: "warmish", q: "Slightly warm." }, { a: "slowish", q: "Somewhat slow." },
            { a: "fastish", q: "Somewhat fast." }, { a: "flatish", q: "Somewhat flat." },
            { a: "roundish", q: "Somewhat round." }, { a: "shortish", q: "Somewhat short." },
            { a: "longish", q: "Somewhat long." }, { a: "goodish", q: "Fairly good." },
            { a: "badish", q: "Somewhat bad." }, { a: "hardish", q: "Somewhat hard." },
            { a: "softish", q: "Somewhat soft." }, { a: "sheepish", q: "Embarrassed or shy." },
            { a: "bookish", q: "Fond of reading." }, { a: "owlishes", q: "Wise like an owl." },
            { a: "modish", q: "Trendy." }, { a: "sluggish", q: "Slow-moving." },
            { a: "peckish", q: "Hungry." }, { a: "squeamish", q: "Easily nauseated." },
            { a: "clownish", q: "Funny or silly." }, { a: "waspish", q: "Angry or irritable." }
        ];

        const BOSS_QUESTIONS = [
            { a: "adjective", q: "Does the suffix '-ish' turn a noun into a Verb or Adjective?" },
            { a: "quality of", q: "Does '-ish' mean 'without' or 'having the quality of'?" },
            { a: "noun", q: "To make 'Foolish', do you add -ish to a Noun or Verb?" },
            { a: "somewhat", q: "In 'Greenish', does it mean 'very' or 'somewhat'?" },
            { a: "approximation", q: "In 'Seven-ish', does it imply precision or approximation?" }
        ];

        // --- 5. GAME STATE ---
        let player = { x: 1, y: 1 };
        let inventory = { keys: 0, vision: false };
        let levelIdx = 0;
        let isPaused = false;
        let currentEnemy = null;
        let walls = [];
        let items = [];
        let moveTimer = 0;

        // --- 6. LEVELS (REDESIGNED FOR MANDATORY KEYS) ---
        const LEVELS = [
            // LEVEL 1: Tutorial
            // Simple: Get Key -> Open Door -> Exit
            [
                "####################",
                "#@.......E....K....#", // Key in open
                "#.N................#", 
                "#######D############", // Door blocks exit
                "#...........E......#", 
                "#...P.......#......#", 
                "#...#.......E......#", 
                "#...#...E....>.....#",
                "#...#..............#",
                "####################"
            ],
            // LEVEL 2: The Loop
            // Start Top Left. Key is bottom Right. Door is Top Middle.
            // You MUST go all the way around to get the key, then come back.
            [
                "#######################",
                "#@....#...D.......>...#", // Door 'D' blocks exit '>'
                "#####.#.#######.#######",
                "#...#.#.#.....#.......#",
                "#...E.#.#..E..#...E...#",
                "#.....#.#.....#.......#",
                "#.#####.#######.#######",
                "#P...................K#", // Key 'K' is far away
                "#######################"
            ],
            // LEVEL 3: The Throne Room
            // Start Left. Key Top Right. Boss locked in center.
            [
                "#######################",
                "#@..............E.....#",
                "#######.#######.#######",
                "#.....#.#.....#.#K....#", // Key is deep in
                "#.....#.#.$...#.#.....#",
                "#.....#.#.....#.#.....#",
                "#.#####.###D###.#######", // Door protects Boss '$'
                "#.........H...........#",
                "#######################"
            ]
        ];

        function loadLevel(idx) {
            levelIdx = idx;
            if (levelIdx >= LEVELS.length) {
                Audio.win();
                alert("CONGRATULATIONS! YOU HAVE CONQUERED SUFFIXIA!");
                location.reload(); 
                return;
            } else if (idx > 0) {
                Audio.win(); // Level up sound
            }

            const map = LEVELS[levelIdx];
            walls = [];
            items = [];

            for (let y = 0; y < map.length; y++) {
                for (let x = 0; x < map[y].length; x++) {
                    let char = map[y][x];
                    
                    if (char === "#") walls.push({x, y});
                    else if (char === "@") { player.x = x; player.y = y; }
                    else if (char === "E" || char === "$" || char === "H") {
                        let pool = (char === "$") ? BOSS_QUESTIONS : REGULAR_QUESTIONS;
                        let qData = pool[Math.floor(Math.random() * pool.length)];
                        items.push({ 
                            x, y, type: char, quest: qData, id: Math.random(),
                            isMoving: (char === "E") 
                        });
                    } 
                    else if ("KDP>NS".includes(char)) {
                        items.push({ x, y, type: char, id: Math.random() });
                    }
                }
            }
            updateHUD();
        }

        function updateHUD() {
            document.getElementById("key-count").innerText = inventory.keys;
            document.getElementById("potion-status").innerText = inventory.vision ? "ON" : "OFF";
            document.getElementById("potion-status").style.color = inventory.vision ? "#55efc4" : "#636e72";
        }

        // --- 7. GAME LOOP ---
        function gameLoop() {
            if(!isPaused) {
                updateEnemies();
                draw();
            }
            requestAnimationFrame(gameLoop);
        }

        function updateEnemies() {
            moveTimer++;
            if (moveTimer > 80) { 
                moveTimer = 0;
                items.forEach(item => {
                    if (item.isMoving) {
                        let dirs = [[0,1], [0,-1], [1,0], [-1,0]];
                        let move = dirs[Math.floor(Math.random() * dirs.length)];
                        let nx = item.x + move[0];
                        let ny = item.y + move[1];
                        if (!isWall(nx, ny) && !isPlayer(nx, ny) && !isItem(nx, ny)) {
                            item.x = nx;
                            item.y = ny;
                        }
                    }
                });
            }
        }

        function isWall(x, y) { return walls.some(w => w.x === x && w.y === y); }
        function isPlayer(x, y) { return player.x === x && player.y === y; }
        function isItem(x, y) { return items.some(i => i.x === x && i.y === y); }

        // --- 8. DRAWING ---
        function draw() {
            CANVAS.width = window.innerWidth;
            CANVAS.height = window.innerHeight;
            CTX.imageSmoothingEnabled = false;

            CTX.fillStyle = "#050505";
            CTX.fillRect(0, 0, CANVAS.width, CANVAS.height);

            let offsetX = (CANVAS.width / 2) - (player.x * TILE_SIZE) - (TILE_SIZE / 2);
            let offsetY = (CANVAS.height / 2) - (player.y * TILE_SIZE) - (TILE_SIZE / 2);

            CTX.save();
            CTX.translate(offsetX, offsetY);

            // Draw Map
            const map = LEVELS[levelIdx];
            for (let y = 0; y < map.length; y++) {
                for (let x = 0; x < map[y].length; x++) {
                    let char = map[y][x];
                    drawTile(x, y, ".", 0); 
                    if (char === "#") drawTile(x, y, "#", 0);
                }
            }

            // Draw Items
            const bob = Math.sin(Date.now() / 200) * 5;
            items.forEach(item => {
                if (item.type === "H" && !inventory.vision) {
                    // Invisible
                } else {
                    let yOffset = (item.type === "E" || item.type === "N" || item.type === "$") ? bob : 0;
                    drawTile(item.x, item.y, item.type, yOffset);
                }
            });

            // Draw Player
            drawTile(player.x, player.y, "@", bob);

            CTX.restore();
        }

        function drawTile(x, y, type, yOffset) {
            const px = x * TILE_SIZE;
            const py = (y * TILE_SIZE) + yOffset;
            const img = IMAGES[type];

            if (img && img.complete && img.naturalHeight !== 0) {
                CTX.drawImage(img, px, py, TILE_SIZE, TILE_SIZE);
                return;
            } 
            
            if (type === "#") { CTX.fillStyle = "#444"; CTX.fillRect(px, py, TILE_SIZE, TILE_SIZE); return; }
            if (type === ".") { CTX.fillStyle = "#111"; CTX.fillRect(px, py, TILE_SIZE, TILE_SIZE); return; }
            
            CTX.font = (TILE_SIZE * 0.7) + "px Arial";
            CTX.textAlign = "center";
            CTX.textBaseline = "middle";
            let cx = px + TILE_SIZE/2;
            let cy = py + TILE_SIZE/2;

            if (type === "K") { CTX.fillText("ðŸ”‘", cx, cy); }
            else if (type === "D") { CTX.fillStyle = "#a65c00"; CTX.fillRect(px, py, TILE_SIZE, TILE_SIZE); CTX.fillStyle="white"; CTX.fillText("ðŸ”’", cx, cy); }
            else if (type === "P") { CTX.fillText("ðŸ§ª", cx, cy); }
            else if (type === "S") { CTX.fillStyle = "#333"; CTX.fillRect(px, py, TILE_SIZE, TILE_SIZE); CTX.fillStyle="#555"; CTX.fillText("?", cx, cy); } 
            else if (type === "H") { CTX.fillText("âš ï¸", cx, cy); } 
            else if (type === "@") { CTX.fillStyle = "#6c5ce7"; CTX.fillRect(px, py, TILE_SIZE, TILE_SIZE); }
            else if (type === "E") { CTX.fillStyle = "#d63031"; CTX.fillRect(px, py, TILE_SIZE, TILE_SIZE); }
            else if (type === ">") { CTX.fillStyle = "#ffeaa7"; CTX.fillRect(px, py, TILE_SIZE, TILE_SIZE); }
            else { CTX.fillStyle = "green"; CTX.fillRect(px, py, TILE_SIZE, TILE_SIZE); }
        }

        // --- 9. MOVEMENT & INTERACTION ---
        window.addEventListener("keydown", (e) => {
            if (isPaused) return;
            let dx = 0, dy = 0;
            if (e.key === "ArrowLeft") dx = -1;
            if (e.key === "ArrowRight") dx = 1;
            if (e.key === "ArrowUp") dy = -1;
            if (e.key === "ArrowDown") dy = 1;

            if (dx !== 0 || dy !== 0) {
                let nx = player.x + dx;
                let ny = player.y + dy;

                if (isWall(nx, ny)) {
                    Audio.error(); 
                    return; 
                }

                let item = items.find(i => i.x === nx && i.y === ny);
                
                if (item) {
                    if (item.type === "N") {
                        openUI("Wizard", "I heard there is a Key hidden in this very room!", false);
                    } 
                    else if (item.type === "K") {
                        inventory.keys++;
                        updateHUD();
                        Audio.pickup();
                        items = items.filter(i => i !== item); 
                        player.x = nx; player.y = ny;
                    }
                    else if (item.type === "P") {
                        inventory.vision = true;
                        updateHUD();
                        Audio.pickup();
                        openUI("Potion Drinker", "You can now see hidden traps!", false);
                        items = items.filter(i => i !== item); 
                        player.x = nx; player.y = ny;
                    }
                    else if (item.type === "D") {
                        if (inventory.keys > 0) {
                            inventory.keys--;
                            updateHUD();
                            Audio.unlock();
                            items = items.filter(i => i !== item); 
                            openUI("Unlocked!", "You used a key to open the door.", false);
                        } else {
                            Audio.error();
                            openUI("Locked", "You need a key ðŸ”‘ to open this door.", false);
                        }
                    }
                    else if (item.type === "S") {
                        player.x = nx; player.y = ny;
                        Audio.step();
                    }
                    else if (item.type === "E" || item.type === "H") {
                        currentEnemy = item;
                        openUI("BATTLE", item.quest.q, true);
                    }
                    else if (item.type === "$") {
                        currentEnemy = item;
                        openUI("BOSS BATTLE", item.quest.q, true);
                    } 
                    else if (item.type === ">") {
                        loadLevel(levelIdx + 1);
                    }
                } else {
                    player.x = nx;
                    player.y = ny;
                    Audio.step();
                }
            }
        });

        // --- 10. UI LOGIC ---
        const UI = document.getElementById("ui-layer");
        const INPUT = document.getElementById("answer");

        function startGame() {
            document.getElementById("start-screen").style.display = "none";
            Audio.init();
            preloadImages();
            loadLevel(0);
        }

        function openUI(title, text, isBattle) {
            isPaused = true;
            UI.style.display = "block";
            document.getElementById("ui-title").innerText = title;
            document.getElementById("ui-text").innerText = text;
            document.getElementById("feedback").innerText = "";
            INPUT.value = "";

            if (isBattle) {
                document.getElementById("battle-ui").style.display = "block";
                document.getElementById("close-btn").style.display = "none";
                setTimeout(() => INPUT.focus(), 100);
            } else {
                document.getElementById("battle-ui").style.display = "none";
                document.getElementById("close-btn").style.display = "inline-block";
            }
        }

        function closeUI() {
            UI.style.display = "none";
            isPaused = false;
        }

        window.checkAnswer = function() {
            if (!currentEnemy) return;
            const attempt = INPUT.value.toLowerCase().trim();
            const correct = currentEnemy.quest.a.toLowerCase().trim();
            if (attempt === correct) {
                Audio.magic();
                
                // IF BOSS DEFEATED -> GAME OVER/WIN
                if (currentEnemy.type === "$") {
                    items = items.filter(i => i !== currentEnemy);
                    closeUI();
                    Audio.win();
                    setTimeout(() => alert("BOSS DEFEATED! YOU WIN!"), 500);
                    // Force level increment for safety
                    levelIdx++; 
                    if (levelIdx >= LEVELS.length) location.reload();
                    return;
                }

                items = items.filter(i => i !== currentEnemy);
                closeUI();
            } else {
                Audio.error();
                document.getElementById("feedback").innerText = "WRONG! Try again.";
            }
        }

        INPUT.addEventListener("keypress", (e) => {
            if (e.key === "Enter") checkAnswer();
        });
        
        function resize() {
            CANVAS.width = window.innerWidth;
            CANVAS.height = window.innerHeight;
            if(assetsLoaded === totalAssets) draw();
        }
        window.addEventListener('resize', resize);
        window.closeUI = closeUI;

    </script>
</body>
</html>
